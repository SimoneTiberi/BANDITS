% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/run.R
\name{test_DTU}
\alias{test_DTU}
\title{Perform differential splicing}
\usage{
test_DTU(BANDITS_data, prior_precision = NULL, R = 10^4, burn_in = 2
  * 10^3, samples_design, group_col_name = "group", n_cores = 1,
  gene_to_transcript, theshold_pval = 0.1)
}
\arguments{
\item{BANDITS_data}{a 'BANDITS_data' object.}

\item{prior_precision}{a vector with the mean and standard deviation of the log-precision parameter.}

\item{R}{the number of iterations for the MCMC algorithm (after the burn-in).
Min 10^4.
Albeit no difference was observed in simulation studies when increasing 'R' above 10^4, 
we encourage users to possibly use higher values of R (e.g., double) if the computational time allows it.}

\item{burn_in}{the length of the burn-in to be discarded (before convergence is reached).
Min 2*10^3.
Albeit no difference was observed in simulation studies when increasing 'burn_in' above 2*10^3, 
we encourage users to possibly use higher values of R (e.g., double) if the computational time allows it.}

\item{samples_design}{a \code{data.frame} indicating the design of the experiment with one row for each sample:
samples_design must contain a column with the sample id and one with the group id.
Warning: the samples in samples_design must have the same order
as those in the 'path_to_eq_classes' parameter of the \code{\link{create_data}} function.}

\item{group_col_name}{the name of the column of 'samples_design' containing the group id.
By default group_col_name = "group".}

\item{n_cores}{the number of cores to parallelize the tasks on.}

\item{gene_to_transcript}{a matrix or data.frame with a list of gene-to-transcript correspondances.
The first column represents the gene id, while the second one contains the transcript id.}

\item{theshold_pval}{is a threshold between 0 and 1; when running \code{\link{test_DTU}}, if the p.value of a gene is < theshold_pval,
a second (independent) MCMC chain is run and the p.value is re-computed on the aggregation of the two chains.
By defauls theshold_pval = 0.1, while theshold_pval = 1 corresponds to running all chains twice, and theshold_pval = 0 means all chains will only run once.}
}
\value{
A \code{\linkS4class{BANDITS_test}} object.
}
\description{
\code{test_DTU} performs differential splicing, via differential transcript usage (DTU), between 2 or more groups.
Parameters are inferred via Markov chain Monte Carlo (MCMC) techniques and a DTU test is performed 
via a multivariate Wald test on the posterior densities for the average relative abundance of transcripts.
Warning: the samples in samples_design must have the same order
as those in the 'path_to_eq_classes' parameter of the \code{\link{create_data}} function.
}
\examples{
## Preliminary information

# specify the directory of the internal data:
data_dir = system.file("extdata", package = "BANDITS")
data_dir

# load gene_to_transcript matching:
data("gene_tr_id", package = "BANDITS")
# gene_tr_id contains transcripts ids on the first column
# and the corresponding gene ids on the second column:
head(gene_tr_id)

# Specify the directory of the transcript level estimated counts.
sample_names = paste0("sample", seq_len(4))
quant_files = file.path(data_dir, sample_names, "quant.sf")
file.exists(quant_files)

# Load the transcript level estimated counts via tximport:
library(tximport)
txi = tximport(files = quant_files, type = "salmon", txOut = TRUE)
counts = txi$counts
head(counts)

# We define the design of the study: in our case we have 2 groups, 
# that we call "A" and "B" of 2 samples each.
samples_design = data.frame(sample_id = sample_names,
                            group = c("A", "A", "B", "B"))
samples_design

# The groups are defined in:
levels(samples_design$group)



## Optional (recommended): transcript pre-filtering

transcripts_to_keep = filter_transcripts(gene_to_transcript = gene_tr_id,
                                         transcript_counts = counts,
                                         min_transcript_proportion = 0.01,
                                         min_transcript_counts = 10,
                                         min_gene_counts = 20)
head(transcripts_to_keep)



## Load the data:

# compute the Median estimated effective length for each transcript:
eff_len = eff_len_compute(x_eff_len = txi$length)

# specify the path to the equivalence classes:
equiv_classes_files = file.path(data_dir, sample_names, "aux_info", "eq_classes.txt")
file.exists(equiv_classes_files)

# Warning: the sample names in equiv_classes_files must have the same order
# as those in the design object, containted in samples_design.
equiv_classes_files
samples_design$sample_id

# create data and filter internally lowly abundant transcripts:
#input_data = create_data(gene_to_transcript = gene_tr_id,
#                           path_to_eq_classes = equiv_classes_files, eff_len = eff_len, 
#                           n_cores = 2,
#                           transcripts_to_keep = transcripts_to_keep)

# load the pre-computed data:
data("input_data", package = "BANDITS")
input_data

# If transcripts pre-filtering is not wanted, 
# do not specify \\code{transcripts_to_keep} parameter.

# Filter lowly abundant genes:
input_data = filter_genes(input_data, min_counts_per_gene = 20)



## Optional (recommended): infer an informative prior for the precision parameter

# Use the same filtering criteria as in \\code{\\link{filter_transcripts}}; 
# if transcript pre-filtering is not performed, set \\code{min_transcript_proportion},
# \\code{min_transcript_counts} and \\code{min_gene_counts} to 0.

#set.seed(61217)
#precision = prior_precision(gene_to_transcript = gene_tr_id, transcript_counts = counts,
#                       min_transcript_proportion = 0.01, min_transcript_counts = 10,
#                       min_gene_counts = 20, n_cores = 2)

# load the pre-computed precision estimates:
data(precision, package = "BANDITS")

# Plot the histogram of the genewise log-precision estimates.
# The black solid line represents the normally distributed prior distribution 
# for the log-precision parameter.
plot_precision(precision)



## Test for DTU
#set.seed(61217)
#results = test_DTU(BANDITS_data = input_data,
#             prior_precision = precision$prior,
#             samples_design = samples_design,
#             R = 10^4, burn_in = 2*10^3, n_cores = 2,
#             gene_to_transcript = gene_tr_id)

# load the pre-computed results:
data("results", package = "BANDITS")
results

# Visualize the most significant Genes, sorted by gene level significance.
head(top_genes(results))

# Alternatively, gene-level results can also be sorted according to DTU_measure, 
# which is a measure of the strength of the change between the 
# average relative abundances of the two groups.
head(top_genes(results, sort_by = "DTU_measure"))

# Visualize the most significant transcripts, sorted by transcript level significance.
head(top_transcripts(results, sort_by = "transcript"))

# Visualize the convergence output for the most significant genes, 
# sorted by gene level significance.
head(convergence(results))

# We can further use the \\code{gene} function to gather all output for a specific gene:
# gene level, transcript level and convergence results.
top_gene = top_genes(results, n = 1)
gene(results, top_gene$Gene_id)

# Similarly we can use the \\code{transcript} function to gather all output 
# for a specific transcript.
top_transcript = top_transcripts(results, n = 1)
transcript(results, top_transcript$Transcript_id)

#Finally, we can plot the estimated average transcript relative expression 
# in the two groups for a specific gene via \\code{plot_proportions}.
library(ggplot2)
plot_proportions(results, top_gene$Gene_id)

}
\seealso{
\code{\link{create_data}}, \code{\linkS4class{BANDITS_data}}, \code{\linkS4class{BANDITS_test}}
}
\author{
Simone Tiberi \email{simone.tiberi@uzh.ch}
}
